2 types of packages that we can install are:
- simple (regular) dependencies: contain some code that we will include in our own code. So code upon which we built our own application, that why we call it dependencies bc our project and our code depend on them to work correctly. EX: Express, which is the Node framework
ex: slugify- regular dependency
- development dependencies: usually just tools for development, ex: a code bundler like Webpack, like debugger tool or a testing library. They are not neede for production. Means our code is not really depended on them, we simply use them to develop our application
!!! to save it as development dependencie remember after the install command, having "--save-dev". Example: npm install nodemon --save-dev (automatically restart the sever the change)

Nodemon: When we use command npm install packageName --> we only install it locally, it will work on the project but nowhere else


----OVERVIEW OF HOW THE WEB WORK----

Ex: https://www.google.com/maps
-protocol: Http or Https
-domain name: Domain name
-resource: maps

--->we need a way of kind of converting the domain name to real address of the server and that happens through a DNS (Domain Name Server- can think like a phone-book for internet)
--First step: 
	When we open up a website is the browser makes a request to a DNS and this special server will then simply match the web address that we typed into the browser to the server's real IP address.
!!! the domain is not the real adress and DNS will convert it to the real IP address
	After returning from the DNS: the name will become something like http://216.58.211.206:433
-Protocol: Http or https
-IP address: 216.58.211.206
-Port number: default 443 for Http or Https--> has nothing to do with the google Maps resource that we wanted to access

--Second Step: once we have the real web address, a TCP/IP (Transmission Control Protocol/Intenet Protocol- basically they are internet fundamental control system- who set the rules how data moves on the internet) socket connection is established between the browser and the server, which are now finally connected

--Third step: make a request: the request that we make is an HTTP (HyperText Transfer Protocol) request 
Start line: GET /maps HTTP/1.1 ( HTTP method + request target + HTTP version)
there is many many method, but most important ones are:
-GET : requesting data
-POST: sending data 
-PUT : modify data
HTTP request headers (many different possibilities):
- Host: www.google.com
- User-Agent: Mozilla/5.0
- Accept Language: en-US

Request body (only when sending data to server, eg:POST)
<BODY>
---> communication protocol is simply a system of rules allowing 2 or more parties to communicate
Example: in case of the HTTP, it's just protocol that allows clients and web servers to communicate by sending requests and response messages from client to server and back

--Forth Step: getting HTTP response
Start line: HTTP/1.1 200 OK ( HTTP version + status code + status message)
HTTP response Headers(many different possibilities):
- Date: Fri, 18 Jan 2021
- Content-Type:  text/html
- Transfer-Encoding: chunked
Response body (most responses)
<BODY> (should contain the HTML of the website we requested or, for exampla, JSON data coming back from an API or something like that)

--Fifth step: 
index.html is the first to be loaded-> scanned for assets: JS, CSS, images -> process is repeated for each file

----HOW NODE.JS WORK: BEHIND THE SCENCE----
1. Node Architecture
- In term of Node's dependencies, which are just a couple of libraries, that Node depends on in order to work properly. 
- Having several runtime dependencies, and the 2 most important ones are V8(mumbles) and libuv
	+ V8- Fundamental part of Node architecture: Node is a Javascript run time based on Google's V8 engine -> so that's why V8 appears here as a dependency. If it wasn't for V8, Node would have absolutely no way of understanding the JavaScript code that we write
->V8 engine is what converts JS code into machine code that a computer can actually understand. Written uses C++ & JS
	+ Libuv- open source library with a strong focus on asynchronous IO(input/output): this layer  is what gives Node access to the undelying computer operating system, file system, networking and more. Written in C++ NOT JS. Also implements 2 extremely important features of Node.js, which are :
	= Event loop: is responsible for handling easy tasks like executing call backs and network IO
	= Thread pool: is for more heavy work like file access or compression or somthing like that

2. Processes threads and the thread pool
- A process: is just a program in execution.
- A thread: is basically just a sequence of instructions
--> The fact that Node runs in just one single thread, which makes it easy to block Node application. So when the program is initialized, all the top level code is executed, which means all the code that is not inside any callback function. Also, all the modules that your app needs are required and all the callbacks aew registered. Then after all that, the event loop finally starts running.!!! most of the work is done here-> it's really the heart of the entire Node architecture.
---> HOWEVER, some tasks are actually too heavy to be executed in the event loop bc they would block the single thread--> thread pool comes in to give us 4 ADDITIONAL THREADS ( can be configure it up to 128 threads). any heavy tasks will be offloaded automaticall to the thread pool

3. Node JS Event Loop:
----- Event loop: 
- Event loop is were all the application code that is inside callback function is executed ( all code that is not top level code will run in the event loop)
- Node JS is built around callback functions
- Node uses an event-driven architecture:
	+Events are emitted
	+Event loops picks them up
	+Callbacks are called
-When we start the application, the event loop starts running right away, and it has multiple phases ( each phase has a callback queue)
----- Phases:
First: taking care of callbacks of expired timers.
	Eg: setTimeout() function --> so, if there are callback functions from timers that just expired, these are the first ones to be processed by the event loop. So if  a timer expires later during the time when one of the other phases are being processed-> then the callback of the timer will only be called as soon as the event loop comes back to this first phase
	-> Callbacks in each queue are processed one by one until there are no ones left in the queue, and only then, the event loop will enter the next phase.

Second: I/O polling and callbacks-> polling: looking for new I/O events that ready to be processed and putting them into the callback queue

Third: Setlmmediate callbacks-> setlmmediate is special kind of timer that we can use if we want to process callbacks immediately after I/O polling and execution phase

Final: close callbacks
	Eg: a web server or a WebSocket shut down

4.Events and Event-driven Architecture:
Event emitter--> Event listenier --> attached callback function
----- Event emitters:
- emit named events as soon as something important happens in the app ( such as a request hitting server, ot a timer expiring, or like a file finishing to read)
- These events can then be picked up by event listeners

----- Event listener:
- event listener is ones that we developers set up, which will fire off callback functions that are attached to each listener

Example: Code to create a server:
const server= http.createServer();
server.on('request', (req,res) => {
	console.log('Request received');
	res.end('Request received');
});
-This server.on method is how we create a listener, 'request' is an event
- Let's say we have a server running, and a new request made. The server acts as an emitter, and will automatically emit an event called "request" each time that a request hits the server
- Then, since we already have a listener set up for this exact event, the callback function that we attached to this listener will automatically be called

5. Streams:
- Stream: used to process (read and write) data piece by piece (chunks), without completing the whole read or write operation, and therefore without keeping all the data in the memory
	Example: when we read a file using streams, we read part of the data, do something with it, then free our memory, and repeat this until the entire file has been processed
	Example: Netflix or Youtube- streaming companies bc they stream video using the same principle--> So, instead of waiting until the entire video file loads, the processing is done piece by piece or in chunkcs so that you can start watching even before the entire file has been downloaded

- in Node, there are 4 fundamental types of stream:
	+ Readable stream: streams that we can read(consume) the data
			Example: http request, fs read stream
			Important events: data, end
			important functions: read() ,pipe()- allows us to plug streams together, passing data from one stream to another w/o having to worry much about events at all
	+ Writable stream: steams to which we can write data
			Example: http responses, fs write stream
			Important events: drain, finish
			important functions: write(), end()
	+ Duplex stream: stream that are both readable and writable
			Example: net web socket
	+ Transform stream: Duplex streams that transform data as it is writen or read
			Example: z lib Gzip creation

6. How Requiring Modules Really Work
---- The commonJS module system:
- Each JS file is treated as a seperate module
- Node.js uses the CommonJS module system: require(), exports or module.exports;
- ES module system is used in browsers: import/export;
- There have been attempts to bring ES module to node.js(.mjs)

---- What happens when we require() a module: 
Resolving& loading -> wrapping -> execution -> returning exports ->caching

First: How does Node know which file to load when we require a module? 
- Note: we have 3 dif kinds of modules:
	+ Core module: require('http')
	+ Developer module: require('./lib/controller');
	+ 3rd party modules (from NPM): require('express');
--> This process is known as resolving the file path: How node decides which module to load: 1.Start with core modules-> 2. If begins with './' or '../' , it will try to loaad developwe module -> 3. if no file found, it will try to find with index.js in it -> 4. els, it will go to node.moduls/ and try to fin module there.

Second: Where does the require function actually come from and why do we have access to it?

--> after the module is loaded, the module's code is wrapped into a special function which will give us access to a could of special objects. It because the nodejs run time, take the code off out module and puts it inside the immediately invoked function expression, or IIFE 
(function(exports, require, module, __filename, __firname){
	//Module code lives here...
});
So node actually doesn't directly execute the code that I rewrite into a file, but instead the wrapper function that will contain our code in its body. It also passes the export, require, module, filename, dir object into it, so that is why in every module we automatically have access to stuff like 'require' funtion-> so these are basically like global variables that are injected into each and every module. By doing it, it achives 2 things:
	1. giving developes access to all these variables we just talked about, which is very helpful
	2. it keeps the top-level variables that we define in our modules private, it's scoped only to the current module instead of leaking everything into the global object.
		example: we declared a variable x in one of our modules and then included an npm module that also used a variable called x-> without this mechanism, out own variable would then get overridden and the entire app would just not work. So each modulehaving its private scope is absolutely crucial and is achieved through this clever trick of wrapping out code into this special function

Third: the code in the module, ot to be more precise, in the module's wrapper function, actually gets executed by the NODE.JS runtime

Forth: 'require' function returns something ( the exports of the require module)

Last: module are actually cached after the first time they are loaded -> if you require the same module multiple times, you will always get the same result (the code in the modules is actually only executed in the first call)



----ASYNCHRONOUS JAVASCRIPT: PROMISES AND ASYNC/AWAIT----
1. The problem with Callbacks: callback Hell: callbacks nest inside callbacks will create a triangle=> they make our code look a bit messy and it makes code difficult to understanda nd also in general, hard to maintain===> HELL

2. From Callbacks Hell to Promises:
- A promise is basically implemented the concept of a future value( the value that we expecting to receive some time in the future)
- We can imagine we saying " Hey server, please get me a random dog image in the background and let me know when you're ready and then give me that data back"
==> So, the promise doesn't have a value yet, because the server actually still getting the data from the server asynchronously in the background but the promises is immediately available and basically promisng us that it will get some date back in the future
==> Promises as soon as it comes back with the data is called a resoled promise ( can be either successful : fulfilled promises, or error: rejected promises

----EXPRESS: LET'S START BUILDING THE NATOUR API----
1. What is Express?
- Express is a minimal node.js framework, a higher level of abstraction
- Express contains a very robust set of features: complex routing, easier handling of requests and responses, middleware, server-side rendering,etc;
- Express allows for rapid development of node.js application: we don't have to re-invent the wheel
- Express makes it easier to organize our application into the MVC architecture

2. APIS and Restful API Design
- API- Application Programming Interface: a piece of software that can be used by another piece of software, in order to allow application to talk to each other
	Example: Web API: the most widely used type of API out there. In fact, APISs aren't only used to send data, and aren't always realated to web development or Javascript...
-----> Application: in API, an application means many different things as long as the piece of software is relatively stand alone. We can say that they are small pieces of software and we can use them, we can interact with them by using their API
	Example of application: Node File System, or HTTP Modules
	Example of applicatio interact with API: 
		1. When we use readfile function from the FS Module, we are actually using the FS API -> that's why sometimes we hear the term node APIs and that usually simply refers to the core node modules that we can interact with.
		2. When we do DOM manipulation in the browser, we are not really using the Javascript language itself, but rather, the DOM API that the browser exposes to us, so it gives us access to it
		3. let's say we create a class in any programming language like Java and then add some public methods or properties to it. THese methods will then be the API of each object create from that class becasue we're giving other pieces of software the possibility of interacting with out initial piece of software, the objects , in this case.

- REST- Representational States Transfer: basically a way of building web APIs in a logical way, making them easy to consume because remember, we build an API for ourselves or for others to consume. we want to make the process of actually using the API as smooth as possible for the user
---> To build RESTful APIs means APIs following the REST architecture
	1. separate API into logical resources
	2. expose structure, resource-based URL (means to be made available)
	3. use HTTP methods( verbs)
	4. sebd data as JSON (usually)
	5. Must be stateless
	--> Resource: Object or representation of something, which has data associated to it. Any information that can be named can be a resource  ( eg: tours, users, reviews...). !!! MUST be a NOUN, NOT a VERB
	--> Expose -Make it available: the data using some structured URLS that te client cna send a request to. Eg: URL: https://www. natours.com/<endpoint>
		---> endpoint: should only contain resources(nouns). and use HTTP methods for action
		Example and explanation:
		/getTour: to read data from the tour ---> GET /tours"/7"->tour id
		/addNewTour: to create data about the new tour ---> POST/tours -> no ID will be sent bc the browser should figure out the new id of the new added
		/updateTour: to update the data --->entirely:  PUT /tours/id or just a part: PATCH /tours/id
		/deleteTour: to delete the data --->DELETE /tours/id
	--> JSON: a very lightweight data interchange format which is heavily used by web APIs coded in any programming language. It's so widely used today because it's really easy for both humans and computers to understand and write JSON
	--> Stateless RESTful API: all state is handled on the client. This means that each request must contain all the information necessary to process a certain request. The server should not have to remember previous request ( eg: loggedIn, currentPage)

3. Handling POST request:
- POST request: we can send dtaa from the client to the server. This data is then ideally available on the request. The request object again is what holds all the data, all the information, about the request that was done. If that request contains some data that was sent, that data should be on the request. Now out of the box, Express does not put that body data on the request, and in order to hace that data available, we have to use somthing called middleware
- Middleware: a function that can modify the incoming request data. It's called middleware because it stands between, so in the middle of the request and the response, and it's just a step that the request goes through while it's being processed

4. Middleware and The Request-Response Cycle
- To start the request-response cycle, or Express app receives a request when someone hits a server for which it will then create a request and response object.
- There is data will then be used and processed in order to generate and send back a meaningful reponse---> In order to process that data, in Express we use something called middleware, which can manipulate the request or the response object.
- Middleware doesn't alwasy have to be just about the request or the response object, but it's usually is mostly about the request
	Ex: using middleware :express.json -> get access to the request body on the request object
- Middleware: it's a function that is executed between, so in the middle of receiving the request and sending the response. So, we can actually say that in Express EVERYTHING is middleware.

INCOMING REQUEST --> //Middleware next() (parsing body) --> //Middleware next()(logging function) --> //Middleware next()(setting headers) --> //Middleware res.send(...)(router) --> RESPONSE
---------> At incoming request, create request object and response object, both of them gonna go through each middleware (You can think og this whole process as kind of a pipeline where our data go through, so just like its been piped from the request to final response). At the last middleware, will send the response to the client

- Middleware stack: is all the middleware together, the order is the order we define it in the code

5. Creating our own middleware
app.use((req,res,next)=>{...});

6. Using third-party middleware:
npm i morgan

7. Create and Mounting Multiple Routers
- Ultimate goal: create and separate all the code that we have in this file into multiple files -> so what we want, is to have one file that only contains all of tours routes then I want to have another file, which has the routes for the users. And will have a file contains all the route handlers for tours, and another for all route handler for users.
- So we can say all our routes right now is kinda on a same router, which is the app object --> so if we want to separate these routes into different files, the best way is create one router for each resource

8.Serving static file:
- static files: the file that are sitting in our file system that we currently cannot access using all routes. Eg: overview.html in public folder
---> So, if we actually want to access something from our file system, we need to use a built-in Express middleware
- after serve the static file, why don't we need the name of the folder anymore? -> Simply because when we're open up a URL that it can't find in any of our routes, it will then look in that public folder that we defined and it sets that folder to the root

9. Environment Variables:
- NodeJS, or Express apps, can run in different environments, and the most important ones are: development environment & production environment
- Depending on the environment, we might use different databases. Eg: we might turn login on/ off, we might turn debugging on/off, really all kinds of different settings that might change depending on the development that we're in. BY default is development
- To check: console.log(app.get('env')


----INTRODUCTION TO MONGODB----
- Traditional database is called relational database
- MongoDB is a database, and it's also called noSQL(no sequel) database
- In Mongo, each databse can contain one ore more collections (tables). Each collection can contain one or more data structures called documents (a row in the table). Each document contains data about 1 single entity.
- The collection is like the parent structure that contains all these entities. Eg: a blog collection for all posts, a user collection or a review collection

1.What is MongoDB:
-MongoDB: is a document database with the scalability and flexibility that you want with the querying and indexing that you need
-----> Document based: MongoDB stores data in documents( field-value pair data structures, noSQL)
-----> Scablable: Very easy to distribute data across multiple machines as your users and amount of data grow
-----> Flexible: No document data schema required, so each document can have different number and type of fields
-----> Performant: Embedded data models, indexing, sharding, flexible documents, native duplication, etc.
- Document structure:
	+BSON( maxSize/document=16MB, uniqueID): data format mongoDB uses for data storage. Like JSON, but typed--> Mongo documents are typed ( means all values will have a data type such as string, Boolean, date...)
	+fields=columns ; 
	+Embedding/Denormalizing: Including related data into a single document. THis allows for quicker access and easier data models (it's not always the best solution tho)


----USING MONGODB WITH MONGOOSE----
1. What is Mongoose?
- Mongoose is an Object Data Modeling(ODM) library for MongoDB and Node.js, a higher level of abstraction
- Mongoose allows for rapid and simple development of mongoDB database interaction
- Features: schemas to model data and relationships, easy data validation, simple query API, middleware, etc.
- Mongoose schema: where we model our data, by describing the structure of the data, default values, and validation
- Mongoose model: a wrapper for the schema, providing an interface to the database for CRUD operations

2. Create a simple model:
- Mongoose is all about MODEL
- Model is like a blueprint that we use to create documents( it's abit like classes in JS) ->use this blueprint in order to create objects
- To create a model, we need SCHEMA (to set default values, validate the data,etc.) 

3. Intro to Back-End Architecture: MVC, Types of Logic, and more
- MVC: Model-View- Controller (Business Logic-Presentation Logic- Application Logic)
-----> Model layer: is concerned with everything about applications data (business logic)
-----> Controller layer: handle the application's request, interact with models, and send back response to the client (application logic)
-----> View layer: is necessary if we have graphical interface in our app, consist of the templates used to generate the view, so the website that we're going to send back to the client (presentation logic)

REQUEST--> Router( tourRouter.js,userRouter.js) --> CONTROLLER(tourCOntroller.js, userController.js) -->MODEL (tourModel.js, userModel.js) send back data--> optional:VIEW (overview.pug, tour.pug, login.pug) --> RESPONSE

-Application Logic: what makes the code actually works (eg: a big part of application logic in Express is all about managing requests and responses)--> more about technical stuff
-----> Code that is only concerned about the application's implementation, not the underlying business problem we're trying to solve (eg: showing/ selling tours, managing stock in the market, organize a library)

- Business Logic: All the code that solves the business problem we set out to solve.
	Eg: Goal is to show tours to customers and then sell them:
		+ Creating new tours in the database
		+ Checking if the user's password is correct
		+ Validate user input data
		+ Ensuring only users who bought a tour can review it 
-----> The code that directly related to the business rules to how the business works, and the business needs, is business logic. 

- Application Logic and Business Logic are almosr impossible to completelly separate, sometimes they will overlap. Do our best to keep: application logic in Controllers/ Business logic in Models
- Fat models/thin controllers: Should off load as much logic as possible into the models, and keep the conttrollers as simple and lean as possible

4. Aggregation Pipeline: Matching& Grouping
$unwind: deconstruc an array field from the info documents and then output one document for each element of the array
$match: select document match the conditions

5. Virtual Properties
- Basically fields that we can deifne on our schema but that will not be persisted--> means they will not be saved into the database in order to save us some space
- Usually use for fields that can be derived from one another
	Eg: a conversion from miles to kilometers => it does NOT make sense to store 2 fields in a database if we can easily convert one to another
- If we just define the virtual property like this : tourSchema.virtual('durationWeeks').get(funtion(){ return this.duration/7; }) ==> durationWeeks will executes anytime we get the data, but it will be found nowhere in the database==> We need to explicitly define it in our schema that we watne the virtual properties in our output ===> in Mongoose.schema {...,{toJSON:{virtuals: true}, toObject:{virtuals:true}}}

5. Document Middleware:	---hook 'save'
- Just like Express, Mongoose also has middleware: which make something happen between 2 events
	eg: Each time a new document is saved to the database, we can run a function between the save command is issued and the actual saving of the document, or also after the actual savin==> g
- Because we can define middleware functions to run before or after a certain event( eg: saving a document to the database)=> this is the reason why Mongoose middleware is also called pre&post hooks
- Document Middleware: tourSchema.pre('save',function(){})=> runs before save() and create(), but !!!NOT .insertMany()
==> This is the document look like right before it saved into the database. So at this point of time, we can still act on the data before it is then saved to the database and that is exactly what we're gonna do now
tourSchema.post('save',function(){})=> runs after save() and create(), but !!!NOT .insertMany()

6. Query Middleware:	--- hook 'find'
- Query middleware allows us to run functions before or after a certain query is executed

7. Aggregate Middleware: --- hook 'aggregate'

8.Data Validation in Mongoose --Built-in Validators
- Validation is basically checking if the enterd values are in the right format for each field in our document schema, and also that values have actually been entered for all the required fields
- Sanitization is to ensure that the inputted data is basically clean, so that there is no malicious code being injected into our database, or into the application itself--> so that step we removeunwanted characters or even code from the input data
!!!! Really crucial: NEVER EVER ACCEPT DATA FROM USER AS IT IS 




----ERROR HANDLING WITH EXPRESSION----
1. Debugging Node.js with ndb:
- Install the package npm i ndb --global
- Go to package.json, add to "scripts": "debug": "ndb server.js"--> A headless Chrome should be opened

- Debugging: the fundamental aspect of the debugging is to set break points
- Breakpoints: are basically the points in our code that we can define in the debugger, wherer our code will then stop running--> it will basically freeze in timeand we can then take a look at all our variables

2. Handling Unhandled Routes:
- Add this response to your app.js:
	app.all('*',(req,res,next)=>{
		res.status(404).json({
			status: 'fail',
			message: 'Can't find ${req.originalUrl} on this server
		});
	}
===> Why and How it works? - The idea is that if we are able to reach this point here then it means that the req/res cycle was not yet finished at this point in our code. Because remember that middleware stack in the order that it's defined here in our code, so basically these code that specify the routes run first, and so if the roue was matched here the our request would never even reach this "error code" ===> should always be LAST PART after all other routes 

3. An Overview of Error Handling:
- OPERATIONAL ERRORS(focus): Problem that we can predict will happen at some point, so we ust need to handle them in advance
	+ Invalid path accessed
	+ In valid user input (validator error from Mongoose)
	+ Failed to connect server
	+ Fail to connect database
	+ Request timeout

- PROGRAMMING ERRORS: Bugs that we developers introduce into our code. Difficult to find and handle
	+ Reading properties on undefined
	+ Passing a number where an object is expected
	+ Using await without async
	+ Using req.query instead of req
	+


4. Implement A Global Error Handling Middleware
- The goal is to write a error middleware is gonna be able to handle operational errors --> any types of errors is in 1 central place
- Error Middleware function:
 
	app.use((err, req,res,next)=>{
		err.statusCode=err.statusCode||500;
		err.status=err.status||'error';
		
		res.status(err.statusCode).json({
			status:err.statusCode,
			message: err.message
		})
	}

- Example of using in handle undefine routes:
	app.all('*', (req,res,next) => {
		const err= new Error(`Can't find ${req.originalUrl} in the server`);
		err.statusCode=404;
		err.status='fail';

		next(err);
	});



---USER'S---
- User authentication and authorization: this is the whole work flow of logging users in and allowing them with certain protected resources that non-logged in users cannot access 

1. How Authentication with JWT Works
- Json Web Tokens are a stateless solution for authentication. So, there is no need to store any session state on the server which of course is perfect for restful APIs like the one that we're building
- How it works: Assuming we already have a registered user in our database, this is how a user logs into the app. So the user's client starts by making a POST request with the username or email and the password. The application then checks if the user exist and if the password is correct. And if so, a unique Json Web Token for only that user is created using a secret string that stored on a server. The server then sends that JWT back to the client which will store it either in a cookie or in a local storage. And just like this the user is authenticated and basically logged into our application without leaving anystate on the server----> The server actually does NOT know which users are logged in. But of course, the user knows that he's logged in bc he has a valid JWT which is a bit like a passport to access protected parts of the application.
!!!! Shorten: A user is logged in as soon as he get back his unique valid JWT which is not saved anywhere on the server--> Therefore, the process is completely stateless. Then each time a user wants to access a protected route like his user profile data, he send his JWT along with a request (it's like showing his passport to get access to that route)
!!!! Important: all this communication must happen over https. So secure encrypted http in order to prevent that anyone can get access to passwords or JWT. Only then we have a really secure system

